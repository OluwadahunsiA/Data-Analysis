#!/usr/bin/env python
# coding: utf-8

# # Урок 2. Масштабирование признаков. Регуляризация. Стохастический градиентный спуск.

# **План занятия**
# 
# * [Теоретическая часть](#theory)
#     * [Масштабирование признаков](#0)
#     * [Стохастический градиентный спуск](#1)
#     * [SGD своими руками](#sgd_manual)
#     * [Переобучение](#overfit)
#     * [Методы борьбы с переобучением](#methods)
#         * [Регуляризация](#reg)
# * [Практическая часть](#practice)
#     * [Домашнее задание](#hw)

# ## <center>Теоретическая часть<a class="anchor" id="theory"></a><center>

# ## Масштабирование признаков <a class='anchor' id='0'>

# В машинном обучении при работе с линейными моделями полезной является практика _масштабирования признаков_. Многие методы машинного обучения, в том числе и линейные, наиболее эффективны в том случае, когда признаки имеют одинаковый масштаб. По сути масштабирование означает приведение признаков к какой-то единой шкале. 

# Существует большое количество методов масштабирования, наиболее популярными из которых являются _нормализация_ и _стандартизация_.
# 
# Метод **нормализации** заключается в приведении признаков к масштабу в диапазоне [0-1].
# 
# Для его реализации необходимо найти минимальное $min_{j} (x^{j}_{i})$ и максимальное $max_{j} (x^{j}_{i})$ значение признака на обучающей выборке. При этом отмасштабированное значение признака будет находиться по формуле
# 
# $$x^{j}_{i} = \frac{x^{j}_{i} - min_{j} (x^{j}_{i})}{max_{j} (x^{j}_{i})-min_{j} (x^{j}_{i})}.$$
# 
# После преобразования значений признаков минимальное значение превратится в 0, а максимальное - в 1.
# 
# Пример различия в сходимости алгоритма на сырых и нормализованных данных:
# <img src="images/L2_normalization.png" style="width: 500px;">
# 
# **Стандартизация** заключается в получении своего рода значения сдвига каждого признака от среднего. Для ее реализации необходимо вычислить среднее значение признака 
# 
# $$\mu_{j} = \frac{1}{l}\sum^{l}_{i=1}x^{j}_{i}$$
# 
# и стандартное отклонение, которое находится путем суммирования квадратов отклонения значений признака на объектах выборки от среднего $\mu_{j}$ и делением на число объектов выборки с последующим извлечением корня:
# 
# $$\sigma_{j} = \sqrt{\frac{1}{l}\sum^{l}_{i=1}(x^{j}_{i}-\mu_{j})^{2}}$$
# 
# Чтобы отмасштабировать признак, каждое его значение преобразуется по формуле
# 
# $$x^{j}_{i}=\frac{x^{j}_{i} - \mu_{j}}{\sigma_{j}}.$$

# Масштабирование является важным этапом подготовки данных перед применением методов машинного обучения. 
# 
# Важным и последним свойством масштабирования является факт, что после масштабирования признаков в линейных моделях веса при них могут интерпретироваться как мера значимости этих признаков.
# 
# Существуют различные ситуации, когда целесообразно применять тот или иной метод масштабирования. Нормализовать полезно признаки, опирающиеся на величину значений - такие как расстояние (knn, k-means). Стандартизировать полезно признаки для модели, которая опирается на распределение (линейные модели). В общем случае, когда выбор метода неочевиден, полезной практикой считается создавать масштабированные копии набора данных, с которыми работает специалист, и сравнивать друг с другом полученные после применения модели результаты для выявления оптимального метода масштабирования для имеющейся ситуации.

# ## Стохастический градиентный спуск <a class='anchor' id='1'>

# 1. Инициализация w
# 
# 2. Цикл по k = 1,2,3,...:
# 
#     * $w^{k} = w^{k-1} - \eta_{k}\nabla Q(w^{k-1}, X)$
# 
#     * Если $||w^{k} - w^{k-1}|| < \epsilon$, то завершить.
# 

# Вспомним метод градиентного спуска, рассмотренный ранее.
# 
# На каждой итерации приближение получается вычитанием из предыдущего вектора градиента, умноженного на некоторый шаг:
# 
# 
# $$w^{k} = w^{k-1} - \eta_{k}\nabla Q(w^{k-1}, X).$$
# 
# При этом выражение градиента в матричной форме выглядит так:
# 
# $$\nabla_{w}Q(w,X) = \frac{2}{l}X^{T}(Xw-y).$$
# 
# Если расписать $j$-ю компонетну этого градиента, то получим
# 
# $$\frac{\partial Q}{\partial w_{j}} = \frac{2}{l}\sum^{l}_{i=1}x^{j}_{i}(\left \langle w,x_{i} \right \rangle - y_{i}),$$
# 
# то есть суммирование по всем $l$ объектам обучающей выборки. Здесь выражение под суммой показывает, как нужно изменить $j$-й вес, чтобы как можно сильнее улучшить качество __на объекте $x_{i}$__, а вся сумма показывает, как нужно изменить вес, чтобы улучшить качество на __всей выборке__.
# 
# В этой формуле отражен один из главных недостатков градиентного спуска: если выборка большая по объему, то даже один шаг градиентного спуска будет занимать много вычислительных ресурсов и времени.

# Стремление к оптимизации процесса привело к появлению _стохастического градиентного спуска_ (Stochastic gradient descent, SGD). Идея его основана на том, что на одной итерации мы вычитаем не вектор градиента, вычисленный по всей выборке, а вместо этого случайно выбираем один объект из обучающей выборки $x_{i}$ и вычисляем градиент только на этом объекте, то есть градиент только одного слагаемого в функционале ошибки и вычитаем именно этот градиент из текущего приближения вектора весов:
# 
# $$w^{k} = w^{k-1} - \eta_{k}\nabla Q(w^{k-1}, \{x_{i}\}),$$
# 
# то есть $\nabla Q(w^{k-1}, X)$ заменяется на $\nabla Q(w^{k-1}, \{x_{i}\})$.

# Если в случае градиентного спуска мы стараемся на каждой итерации уменьшить ошибку на всей выборке, и по мере увеличения числа итераций ошибка падает монотонно, то в случае стохастического градиентного спуска мы уменьшаем на каждой итерации ошибку только на одном объекте, но при этом есть вероятность увеличить ее на другом объекте, поэтому график изменения ошибки может получаться немонотонным, и даже иметь пики (см. пример по ссылке [1] из списка литературы). То есть на какой-то итерации мы можем даже увеличить ошибку, но при этом в целом по ходу метода ошибка снижается, и рано или поздно мы выходим на нормальный уровень.

# 1. Инициализация w
# 
# 2. Цикл по k = 1,2,3,...:
# 
#     * Выбираем случайные объект $x_{i}$ из X
#     * $w^{k} = w^{k-1} - \eta_{k}\nabla Q(w^{k-1}, \{x_{i}\})$
#     * Если $||w^{k} - w^{k-1}|| < \epsilon$, то завершить.
# 

# <img src="images/compare_gd_sgd.png" width=550px>

# ## SGD своими руками<a class="anchor" id="sgd_manual"></a>

# Реализуем стохастический градиентный спуск своими руками.

# In[1]:


import numpy as np
from sklearn import datasets
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.axes3d import Axes3D

get_ipython().run_line_magic('matplotlib', 'inline')
import warnings
warnings.filterwarnings('ignore')


# In[69]:


# сгенерируем набор данных
X, Y, coef = datasets.make_regression(n_samples=1000, n_features=2, n_informative=2, n_targets=1, 
                                      noise=5, coef=True, random_state=2)
X[:, 0] *= 10
display(X, Y, coef)


# In[70]:


fig = plt.figure(figsize=(15,10))
ax = fig.add_subplot(111, projection='3d')

ax.scatter(X[:, 0], X[:, 1], Y)

ax.set_xlabel('X0')
ax.set_ylabel('X1')
ax.set_zlabel('Y')
plt.show()


# Отмасштабируем получившиеся признаки методом стандартизации.

# In[71]:


# Получим средние значения и стандартное отклонение по столбцам

means = np.mean(X, axis=0)
stds = np.std(X, axis=0)
# параметр axis указывается для вычисления значений по столбцам, а не по всему массиву
display(means, stds)


# In[72]:


X.shape[0]


# In[73]:


# вычтем каждое значение признака из среднего и поделим на стандартное отклонение
for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        X[i][j] = (X[i][j] - means[j]) / stds[j]


# In[74]:


X


# In[75]:


means = np.mean(X, axis=0)
stds = np.std(X, axis=0)

display(means, stds)


# In[76]:


# реализуем функцию, определяющую среднеквадратичную ошибку
def mserror(X, w, y_pred):
    y = X.dot(w)
    return (sum((y - y_pred)**2)) / len(y)


# Подготовка данных и средств проверки закончена. Далее реализуем сам стохастический градиентный спуск.

# In[81]:


get_ipython().run_cell_magic('time', '', "# инициализируем начальный вектор весов\nw = np.zeros(X.shape[1])\n\n# список векторов весов после каждой итерации\nw_list = [w.copy()]\n\n# список значений ошибок после каждой итерации\nerrors = []\n\n# шаг градиентного спуска\neta = 0.01\n\n# максимальное число итераций\nmax_iter = 1e3\n\n# критерий сходимости (разница весов, при которой алгоритм останавливается)\nmin_weight_dist = 1e-8\n\n# зададим начальную разницу весов большим числом\nweight_dist = np.inf\n\n# счетчик итераций\niter_num = 0\n\nnp.random.seed(1234)\n\n# ход градиентного спуска\nwhile weight_dist > min_weight_dist and iter_num < max_iter:\n    \n    # генерируем случайный индекс объекта выборки\n    train_ind = np.random.randint(X.shape[0], size=1)\n    \n    y_pred = np.dot(X[train_ind], w)\n    new_w = w - eta * 2 / Y[train_ind].shape[0] * np.dot(X[train_ind].T, y_pred - Y[train_ind])\n\n    weight_dist = np.linalg.norm(new_w - w, ord=2)\n \n    error = mserror(X, new_w, Y)\n    \n    w_list.append(new_w.copy())\n    errors.append(error)\n    \n    if iter_num % 100 == 0:\n        print(f'Iteration #{iter_num}: W_new = {new_w}, MSE = {round(error, 2)}')\n\n    iter_num += 1\n    w = new_w\n    \nw_list = np.array(w_list)\n\nprint(f'Iter {iter_num}: error - {error}, weights: {new_w}')\nprint(f'В случае использования стохастического градиентного спуска ошибка составляет {round(errors[-1], 4)}')")


# Для стохастического градиентного спуска мы увеличили максимальное число итераций (max_iter) до 1000, что естественно, так как из-за специфики метода для достижения сходимости нужно большее количество шагов.

# In[11]:


# Визуализируем изменение весов (красной точкой обозначены истинные веса, сгенерированные вначале)
plt.figure(figsize=(13, 6))
plt.title('Stochastic gradient descent')
plt.xlabel(r'$w_1$')
plt.ylabel(r'$w_2$')

plt.scatter(w_list[:, 0], w_list[:, 1])
plt.scatter(coef[0], coef[1], c='r')
plt.plot(w_list[:, 0], w_list[:, 1])

plt.show()


# In[12]:


# Визуализируем изменение функционала ошибки
plt.plot(range(len(errors)), errors)
plt.title('MSE')
plt.xlabel('Iteration number')
plt.ylabel('MSE')


# Как и в случае градиентного спуска, вектор весов приближается к истинному. При этом падает и ошибка.
# 
# Добиться лучшей скорости сходимости в методе стохастического градиентного спуска можно варьируя величину шага или используя методы, подбирающие ее адаптивно.

# Среди преимуществ SGD можно выделить гораздо более быстрое вычисление одного шага по сравнению с обычным градиентным спуском и отсутствие необходимости хранить всю выборку в памяти при работе метода, что в свою очередь позволяет работать с очень большими выборками, которые невозможно поместить в память.

# ## Переобучение <a class='anchor' id='overfit'>

# Чтобы понять смысл переобучения и недообучения, начнем с примера. Допустим, у нас есть исходная известная зависимость 3-го порядка:
# 
# $$f(x) = 0.6 - 13.2x - 5.3 x^{2} - 4.17x^{3}.$$
# 
# Реализуем ее в виде python-функции и построим график.

# In[13]:


def f(x):
    return 0.6 - 13.2 * x - 5.3 * x ** 2 - 4.17 * x ** 3


# In[14]:


dots = np.linspace(-10, 10, 100)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.ylim(-5000, 5000)
plt.xlim(-10,10)

plt.plot(dots, f(dots), color='g');


# Теперь сгенерируем датасет из десяти случайных точек, подчиняющихся этой зависимости, с добавлением шума и нанесем на график.

# In[15]:


np.random.seed(16)
x_data = np.random.uniform(-10, 10, 10)
f_data = [f(i) for i in x_data] + np.random.uniform(-1000, 1000, 10)


# In[16]:


plt.xlabel('x')
plt.ylabel('f(x)')
plt.ylim(-5000, 5000)
plt.xlim(-10, 10)

plt.plot(dots, f(dots), color='g')
plt.scatter(x_data, f_data);


# Теперь попробуем создать модель, способную восстановить исходную зависимость. Самым примитивным так называемый __константный алгоритм__, то есть модель вида 
# 
# $$a(x) = w_{0}.$$
# 
# Зависимость такой модели от признаков будет иметь вид горизонтальной прямой, что, очевидно, не обобщает нашу зависимость в должном виде (см. график ниже).

# In[17]:


plt.xlabel('x')
plt.ylabel('f(x)')
plt.ylim(-5000, 5000)
plt.xlim(-10, 10)

plt.plot(dots, f(dots), color='g')
plt.scatter(x_data, f_data)
plt.plot(dots, [dots.mean()]*len(dots), color='r');


# Далее усложним семейство алгоритмов, применив линейную регрессию, которая в случае одного признака будет иметь вид 
# 
# $$a(x) = w_{0} + w_{1}x.$$
# 
# Обучим соответствующую модель, применив для этого методы python "из коробки" для работы с линейной регрессией.

# In[18]:


from sklearn.linear_model import LinearRegression

# создадим модель
linear_regressor = LinearRegression()

# обучим ее
linear_regressor.fit(np.reshape(x_data, (-1, 1)), f_data)


# In[19]:


# выведем полученный вес при признаке и свободный коэффициент
print(linear_regressor.coef_[0], linear_regressor.intercept_)


# Нанесем полученную после обучения модель на график

# In[20]:


plt.xlabel('x')
plt.ylabel('f(x)')
plt.ylim(-5000, 5000)
plt.xlim(-10, 10)

plt.plot(dots, f(dots), color='g')
plt.scatter(x_data, f_data)
plt.plot(dots, linear_regressor.predict(np.reshape(dots, (-1, 1))), color='r');


# Мы обучили линейную модель, и видимо, что она, как и константная, плохо восстанавливает исходную зависимость. В данном случае можно говорить о __недообучении__. Хороший алгоритм не был построен, поскольку с помощью выбранного семейства алгоритмов невозможно восстановить исходную закономерность.

# Усложним используемое семейство алгоритмов до кубической зависимости 
# 
# $$a(x) = w_{0} + w_{1}x + w_{2}x^{2} + w_{3}x^{3}.$$
# 
# Сделаем это путем искусственной генерации новой матрицы признаков, состоящей из исходных $x$, возведенных в степени до 3, используя `sklearn.preprocessing.PolynomialFeatures`. 

# Из [статьи](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html) про PolynomialFeatures:
# 
# For example, if an input sample is two dimensional and of the form [a, b], the degree-2 polynomial features are [1, a, b, a^2, ab, b^2].

# In[21]:


from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import make_pipeline
import pandas as pd


# In[22]:


a = pd.DataFrame([[2, 3, 4]], columns=['a', 'b', 'c'])


# In[23]:


a


# In[24]:


PolynomialFeatures(degree=2).fit_transform(a)


# In[25]:


x_data[0]


# In[26]:


PolynomialFeatures(degree=3).fit_transform(x_data[0].reshape(-1, 1))


# In[27]:


x_data[0]**0, x_data[0]**1, x_data[0]**2, x_data[0]**3


# In[31]:


# создадим новую кубическую модель
third_degree_regressor = make_pipeline(PolynomialFeatures(degree=3), LinearRegression())

# обучим ее
third_degree_regressor.fit(np.reshape(x_data, (-1, 1)), f_data)


# In[32]:


# выведем полученные веса при признаках и свободный коэффициент
print(third_degree_regressor.named_steps.linearregression.coef_)
print(third_degree_regressor.named_steps.linearregression.intercept_)


# Нанесем полученную в итоге зависимость на график.

# In[33]:


plt.xlabel('x')
plt.ylabel('f(x)')
plt.ylim(-5000, 5000)
plt.xlim(-10, 10)

plt.plot(dots, f(dots), color='g')
plt.scatter(x_data, f_data)
plt.plot(dots, third_degree_regressor.predict(np.reshape(dots, (-1, 1))), color='r');


# Полученный алгоритм достаточно хорошо описывает данные, но не идеально. И в реальных условиях может возникнуть вопрос, можно ли добиться лучшего совпадения увеличением сложности алгоритма.
# 
# Проиллюстрируем, что происходит в случае использования многочлена 8-й степени.

# In[34]:


# создадим модель 8-й степени
eighth_degree_regressor = make_pipeline(PolynomialFeatures(degree=8), LinearRegression())

# обучим ее
eighth_degree_regressor.fit(np.reshape(x_data, (-1, 1)), f_data)


# Покажем получившийся график зависимости.

# In[35]:


# выведем полученные веса при признаках и свободный коэффициент
print(eighth_degree_regressor.named_steps.linearregression.coef_)
print(eighth_degree_regressor.named_steps.linearregression.intercept_)


# In[36]:


plt.xlabel('x')
plt.ylabel('f(x)')
plt.ylim(-5000, 5000)
plt.xlim(-10, 10)

plt.plot(dots, f(dots), color='g')
plt.scatter(x_data, f_data)
plt.plot(dots, eighth_degree_regressor.predict(np.reshape(dots, (-1, 1))), color='r');


# ## Методы борьбы с переобучением <a class='anchor' id='methods'>

# Видно, что новая модель лучше описывает имеющиеся в обучающей выборке данные и дает фактически идеальные ответы на них, но про этом в целом зависимость сильно отличается от истинной. Поэтому если мы попробуем применить эту модель на новых данных, ответы будут расходиться с правильными. Такое явление и называется __переобучением__. Алгоритм слишком сильно подогнан под обучающую выборку, и за счет этого будет давать неадекватные ответы на новых точках.

# Таким образом, недообучение несет за собой плохое качество на обучении и на новых данных, а переобучение - хорошее качество на обучении и плохое на новых данных.
# 
# Понятно, как бороться с недообучением - усложнять семейство алгоритмов. Возникает вопрос, как выявить переобучение и его избежать. В случае переобучения, как было сказано ранее, данные из обучающей выборки алгоритмом будут описываться хорошо, а новые данные - плохо, поэтому используя только обучающую выборку, невозможно заключить, хорошо обучен алгоритм или переобучен, так как оба они будут хорошо описывать известные данные.

# Есть несколько методов оценки качества алгоритма и выявления переобучения:
# 
# 1. Не использовать всю выборку для обучения, а откладывать часть данных для проверки полученного алгоритма. Это называется **отложенной выборкой**. Данные делятся на обучающую и тестовую выборку в соотношении, например, 0.7 к 0.3, и затем на первой части алгоритм обучается, а на второй проверяется. Размер отложенной выборки в данном случае нужно подбирать с осторожностью, так как слишком маленькая тестовая выборка не будет обеспечивать должной точности оценки качества обучения, а слишком маленькия обучающая выборка приведет к снижению качества обучения, так как будет малорепрезентативна. Таким образом, главный минус этого метода - сильная зависимость результата от того, как мы выбираем отложенную выборку. Например, в пространстве объектов могут быть какие-то особые, отличающиеся от остальных по какому-то свойству объекты, и может так произойти, что после разбиения они не попадут в обучающую выборку, алгоритм на них не обучится, и качество обучения после проверки на этих объектах, попавших в тестовую выборку, будет плохим. Один из путей решения этой проблемы - многократное случайное разбиение выборки на тестовую и обучающую и использование в качестве оценки качества среднего значения ошибки полученной после каждого разбиения. Но и этот метод не гарантирует, что каждый объект побывает в обучающей выборке, так как разбиения случайные.
# <img src="images/valid.png" style="width: 500px;">
# 
# 
# 2. **Кросс-валидация** (усложненная версия метода отложенной выборки). Этот метод как раз вытекает из проблемы, описанной выше. Он является более системным подходом. В этом случае выборка разбивается на $k$ блоков, и затем каждый из них по очереди используется в качестве тестового, а остальная часть - в качестве обучающей выборки. После прохождения всей выборки таким образом получается $k$ показателей качества, и итоговая оценка качества обучения по кросс-валидации оценивается как средняя из этих $k$. В этом случае мы гарантируем, что все данные поучаствуют в обучении. Выбор количества блоков $k$ обычно зависит от размера выборки. Чем больше данных, тем меньше нужно блоков, так как во-первых в этом случае после разбиения даже на малое количество блоков у нас остается большой объем данных в обучающей выборке, что обеспечивает хорошее качество обучения, а во-вторых, разбиение на $k$ блоков означает обучение алгоритма $k$ раз, соответственно, чем их больше, тем больше получается вычислительная сложность процесса обучения модели. Обычно $k$ принимает значение от 3 до 10.
# <img src="images/kfolds.png" style="width: 500px;">
# 
# 
# 3. Использовать **меры сложности модели**, позволяющие без дополнительной выборки выявить переобучение.

# Одним из знаков, что произошло переобучение модели, или _мерой сложности_ является получение больших по модулю весов при признаках. Посмотрим, что получилось в нашей последней модели.

# In[37]:


# выведем полученные веса при признаках и свободный коэффициент
print(eighth_degree_regressor.named_steps.linearregression.coef_)
print(eighth_degree_regressor.named_steps.linearregression.intercept_)


# Видим веса 2 и 3 порядков в то время как в кубичесой модели и в исходной зависимости ничего подобного не было. Это и говорит нам о том, что в данном случае имеет место переобучение.

# На этой особенности и основывается метод _регуляризации_ для борьбы с переобучением.

# ### Регуляризация <a class='anchor' id='reg'>

# #### $L_2$-регуляризация (ridge, регуляризация Тихонова)

# Метод регуляризации заключается в "штрафовании" модели за слишком большие веса путем добавления нового члена к ошибке:
# 
# $$Q(w, X) + \lambda ||w||^{2} \rightarrow \underset{w}{\text{min}}.$$
# 
# добавленный член $\lambda ||w||^{2}$ - **квадратичный регуляризатор**, который представляет собой $L_{2}$-норму вектора весов, то есть сумму квадратов весов $\sum^{d}_{j=1}w_{j}^{2}$, коэффициент $\lambda$ при нем - коэффициент регуляризации. Чем больше его значение, тем меньшая сложность модели будет получаться в процессе такого обучения. Если _увеличивать_ его, в какой-то момент оптимальным для модели окажется зануление всех весов. В то же время при слишком _низких_ его значениях появляется вероятность чрезмерного усложнения модели и переобучения. Выбор оптимального значения этого коэфициента является отдельной задачей и заключается в многократном обучении модели с разными его значениями и сравнении их качества.

# По сути, смысл регуляризации заключается, как и в обычном обучении, в минимизации функционала ошибки, только в данном случае добавляется условие непревышения нормой вектора весов некоторого значения $||w||^{2}\leq C$, то есть ограничение весов, что и будет залогом избежания переобучения.

# $$\begin{cases} Q(w, X) \rightarrow min \\ ||w||^2 \leq C \end{cases}$$

# $$C = \frac{1}{\lambda}$$

# In[82]:


X = np.array([[ 1,  1],
              [ 1,  1],
              [ 1,  2],
              [ 1,  5],
              [ 1,  3],
              [ 1,  0],
              [ 1,  5],
              [ 1, 10],
              [ 1,  1],
              [ 1,  2]])

y = [45, 55, 50, 55, 60, 35, 75, 80, 50, 60]



# На графике ниже изображено изменение весов признаков при увеличении коэффициента регуляризации `alpha` от $10^{-3}$ до $100$ для модели `Ridge` (L2-регуляризация). Чем больше значение `alpha`, тем сильнее регуляризация и тем сильнее модель "штрафует" за большие значения весов, они убывают плавно и примерно одновременно друг с другом.
# 

# In[39]:


np.logspace(-3, 2, 50)


# In[83]:


from sklearn.linear_model import Ridge

n = 50

train_amount = 5
train_X = X[:train_amount]
train_y = y[:train_amount]
test_X = X[train_amount:]
test_y = y[train_amount:]


coeffs = np.zeros((n, train_X.shape[1]))
alpha_list = np.logspace(-3, 2, n)

for i, val in enumerate(alpha_list):
    ridge = Ridge(alpha=val, fit_intercept=False)
    ridge.fit(train_X, train_y)
    
    coeffs[i, :] = ridge.coef_.flatten()

for i in range(train_X.shape[1]):
    plt.plot(alpha_list, coeffs[:, i])

plt.title('Убывание абсолютных значений весов признаков\n при увеличении коэффициента регуляризации alpha (Ridge)')
plt.xticks(np.arange(0, 101, 10))
plt.xlabel('alpha')
plt.ylabel('Вес признака');


# In[91]:


index = 0

coef = coeffs[index]

print(f'Коэффициент регуляризации: {alpha_list[index]}')
print(f'Веса: {coef}')

fig, axs = plt.subplots(1, 2, figsize=(15, 4))
ax1, ax2 = axs

ax1.scatter(train_X[:, 1], train_y)

y_pred = np.dot(train_X, coef)
ax1.plot(train_X[:, 1], y_pred, c='r')

ax1.set_xlabel('X1')
ax1.set_ylabel('Y')
print(f'MSE на обучении: {np.mean((y_pred - train_y)**2)}')

ax2.scatter(test_X[:, 1], test_y)

y_pred = np.dot(test_X, coef)
ax2.plot(test_X[:, 1], y_pred, c='r')

ax2.set_xlabel('X1')
ax2.set_ylabel('Y')
print(f'MSE на тесте: {np.mean((y_pred - test_y)**2)}')
plt.show()


# #### $L_1$-регуляризация (lasso, регуляризация через манхэттенское расстояние)

# Описанный выше метод с использованием $L_{2}$-нормы вектора весов в качестве регуляризатора называется **$L_{2}$-регуляризацией**. По аналогии существует также **$L_{1}$-регуляризация**, использующая в качестве регуляризатора $L_{1}$-норму вектора весов, то есть сумму модулей весов.
# 
# $$||w||_{1} = \sum^{d}_{j=1}|w_{j}|.$$

# На графике ниже изображено изменение весов признаков при увеличении коэффициента регуляризации `alpha` от $10^{-3}$ до $100$ для модели `Lasso` (L1-регуляризация). Чем больше значение `alpha`, тем сильнее регуляризация и тем сильнее модель "штрафует" за большую абсолютную величину признаков. 
# 
# Такой метод часто используется для отбора признаков: у менее ценных признаков гораздо раньше обнуляются веса.

# In[92]:


from sklearn.linear_model import Lasso

n = 50

coeffs = np.zeros((n, train_X.shape[1]))
alpha_list = np.logspace(-3, 2, n)

for i, val in enumerate(alpha_list):
    lasso = Lasso(alpha=val, fit_intercept=False)
    lasso.fit(train_X, train_y)
    coeffs[i, :] = lasso.coef_.flatten()

for i in range(train_X.shape[1]):
    plt.plot(alpha_list, coeffs[:, i])

    
plt.title('Убывание абсолютных значений весов признаков\n при увеличении коэффициента регуляризации alpha (Lasso)')
plt.xticks(np.arange(0, 101, 10))
plt.xlabel('alpha')
plt.ylabel('Вес признака');


# In[100]:


index = 35

coef = coeffs[index]

print(f'Коэффициент регуляризации: {alpha_list[index]}')
print(f'Веса: {coef}')

fig, axs = plt.subplots(1, 2, figsize=(15, 4))
ax1, ax2 = axs

ax1.scatter(train_X[:, 1], train_y)

y_pred = np.dot(train_X, coef)
ax1.plot(train_X[:, 1], y_pred, c='r')

ax1.set_xlabel('X1')
ax1.set_ylabel('Y')
print(f'MSE на обучении: {np.mean((y_pred - train_y)**2)}')

ax2.scatter(test_X[:, 1], test_y)

y_pred = np.dot(test_X, coef)
ax2.plot(test_X[:, 1], y_pred, c='r')

ax2.set_xlabel('X1')
ax2.set_ylabel('Y')
print(f'MSE на тесте: {np.mean((y_pred - test_y)**2)}')
plt.show()


# #### Сравнение

# $L_{2}$-регуляризатор:
# * непрерывная гладкая функция
# * штрафует модель за сложность
# 
# $L_{1}$-регуляризатор:
# * негладкая функция
# * занулении некоторых весов (отбор признаков)

# Регуляризация создает некое абстрактное поле (зеленое) в градиентном спуске (овалы), из которого не может выйти обучение модели. Если мы увеличиваем Лямбду, то поле сужается.
# 
# <img src='images/compare_l1_l2_2.png'>

# Можно применить одновременно L1 и L2 регуляризацию - это называется Elastic Net. Про это можно посмотреть [здесь](https://youtu.be/1dKRdX9bfIo) и почитать в оригинальной [статье](https://web.stanford.edu/~hastie/Papers/B67.2%20(2005)%20301-320%20Zou%20&%20Hastie.pdf).

# ### Коэффициент детерминации

# _Коэффициент детерминации_ $R^{2}$ является еще одной метрикой качества в задачах регрессии. Ранее мы говорили о средней абсолютной и среднеквадратичной ошибке. Коэффициент детерминации позволяет развить тему среднеквадратичной ошибки, интерпретируя ее. 
# 
# MSE не позволяет сама по себе сделать вывод о том, как хорошо модель решает задачу. Например, если целевая переманная принимает значения от 0 до 1, а MSE равняется 10, это плохой показатель, а когда целевая переменная варьируется от 1000 до 10000, такое же значение уже является очень хорошим. Для избавления от такой неясности и был введен коэффициент детерминации, который по сути является нормированной среднеквадратичной ошибкой и принимает значения от 0 до 1.
# 
# $$R^2 = 1 - \frac{\frac{1}{n}\sum^{l}_{i=1}{(y - y_{pred})^2}}{\frac{1}{n}\sum^{l}_{i=1}{(y - \bar{y})^2}}$$
# 
# где $\bar{y}=\frac{1}{l}\sum^{l}_{i=1}y_{i}$ - среднее значение целевой переменной.
# 
# Коэффициент детерминации характеризует, какую долю дисперсии ответов объясняет модель. Если $R^{2}=1$, то модель идеально описывает данные, если же $R^{2}$ близко к нулю, то предсказания сопоставимы по качеству с константной моделью.

# In[44]:


true = np.array([0, 0.2, 0.1, 0.6, 0.3, 0.9, 0.7])
pred = np.array([0.1, 0.3, 0.2, 0.7, 0.5, 0.5, 0.5])

np.mean((true - pred) ** 2)


# In[45]:


true = np.array([100, 20, 10, 60, 30, 90, 70])
pred = np.array([110, 30, 20, 70, 50, 50, 50])

np.mean((true - pred) ** 2)


# ## <center>Практическая часть<a class="anchor" id="practice"></a><center>

# In[2]:


import numpy as np
import matplotlib.pyplot as plt


# __Задача:__ предсказание баллов ЕГЭ ученика

# In[103]:


X = np.array([[   1,    1,  500,    1],
              [   1,    1,  700,    1],
              [   1,    2,  750,    2],
              [   1,    5,  600,    1],
              [   1,    3, 1450,    2],
              [   1,    0,  800,    1],
              [   1,    5, 1500,    3],
              [   1,   10, 2000,    3],
              [   1,    1,  450,    1],
              [   1,    2, 1000,    2]])


# In[104]:


y = [45, 55, 50, 55, 60, 35, 75, 80, 50, 60]


# Нормализация [0, 1]

# In[105]:


X[:, 1].min(), X[:, 1].max()


# In[106]:


X[:, 2].min(), X[:, 2].max()


# In[107]:


def min_max_scale(X):
    return (X - X.min()) / (X.max() - X.min())


# In[108]:


X_norm = X.copy()
X_norm = X_norm.astype(np.float64)
X_norm


# In[109]:


X_norm[:, 1] = min_max_scale(X_norm[:, 1])
X_norm[:, 2] = min_max_scale(X_norm[:, 2])
X_norm[:, 3] = min_max_scale(X_norm[:, 3])
X_norm


# Стандартизация

# In[110]:


print(np.mean(X[:, 1]))
plt.hist(X[:, 1])
plt.show()


# In[111]:


print(np.mean(X[:, 2]))
plt.hist(X[:, 2])
plt.show()


# In[112]:


def standard_scale(X):
    mean = X.mean()
    std = X.std()
    return (X - mean) / std


# In[113]:


X_st = X.copy().astype(np.float64)
X_st[:, 1] = standard_scale(X_st[:, 1])
X_st[:, 2] = standard_scale(X_st[:, 2])
X_st[:, 3] = standard_scale(X_st[:, 3])

X_st


# In[114]:


print(np.mean(X_st[:, 1]))
print(np.std(X_st[:, 1]))

plt.hist(X_st[:, 1])
plt.show()


# In[115]:


print(np.mean(X_st[:, 2]))
print(np.std(X_st[:, 2]))

plt.hist(X_st[:, 2])
plt.show()


# SGD (Stochastic gradient descent)

# In[116]:


def calc_mse(y, y_pred):
    err = np.mean((y - y_pred)**2)
    return err


# In[117]:


W = np.random.randn(X.shape[1])
W


# In[118]:


# классический  GD
def gradient_descent(X, y, iterations, eta=1e-4):
    W = np.random.randn(X.shape[1])
    n = X.shape[0]
    
    for i in range(0, iterations):
        y_pred = np.dot(X, W)
        err = calc_mse(y, y_pred)
        dQ = 2/n * X.T @ (y_pred - y) # градиент функции ошибки
        W -= (eta * dQ)
        if i % (iterations / 10) == 0:
            print(f'Iter: {i}, weights: {W}, error {err}')
    print(f'Final MSE: {calc_mse(y, np.dot(X, W))}')
    return W


# In[119]:


gradient_descent(X_st, y, iterations=5000, eta=1e-2)


# In[141]:


# стохастический градиентный спуск
def stohastic_gradient_descent(X, y, iterations, batch_size, eta=1e-4):
    W = np.random.randn(X.shape[1])
    n = X.shape[0]
    
    n_batch = n // batch_size    
    if n % batch_size != 0:
        n_batch += 1
    print(f'amount of batches is {n_batch}')
        
    for i in range(0, iterations):
        
        for b in range(n_batch):
            inds = np.random.randint(n, size=batch_size)

            X_tmp = X[inds, ]
            y_tmp = np.array(y)[inds]

            
            y_pred_tmp = np.dot(X_tmp, W)
            dQ = 2/len(y_tmp) * X_tmp.T @ (y_pred_tmp - y_tmp) # градиент функции ошибки
            W -= (eta * dQ)
            
            err = calc_mse(y, np.dot(X, W))
        
        if i % (iterations / 10) == 0:
            print(f'Iter: {i}, weights: {W}, error {err}')
    
    print(f'Final MSE: {calc_mse(y, np.dot(X, W))}')
    return W


# In[142]:


stohastic_gradient_descent(X_st, y, iterations=5000, batch_size=4, eta=1e-2)


# ##### L1 регуляризация

# $$Q(w, X) + \lambda |w| \rightarrow \underset{w}{\text{min}}.$$
# Про производную можно посмотреть [здесь](https://youtu.be/dHhYHGI9E6I).

# ##### L2 регуляризация

# $$Q(w, X) + \lambda ||w||^{2} \rightarrow \underset{w}{\text{min}}.$$
# 
# <center>Производная</center>
# 
# $$d\lambda ||w||^{2} = 2\lambda w $$

# In[143]:


def gradient_descent_reg_l2(X, y, iterations, eta=1e-4, reg=1e-8):
    W = np.random.randn(X.shape[1])
    n = X.shape[0]
    
    for i in range(0, iterations):
        y_pred = np.dot(X, W)
        err = calc_mse(y, y_pred)
        
        dQ = 2/n * X.T @ (y_pred - y) # градиент функции ошибки
        dReg = reg * W # градиент регуляризации
        
        W -= eta * (dQ + dReg)
        
        if i % (iterations / 10) == 0:
            print(f'Iter: {i}, weights: {W}, error {err}')
    
    print(f'Final MSE: {calc_mse(y, np.dot(X, W))}')
    return W


# In[149]:


gradient_descent_reg_l2(X_st, y, iterations=5000, eta=1e-1, reg=1e-4)


# In[68]:


gradient_descent(X_st, y, iterations=5000, eta=1e-1)


# ## Домашнее задание <a class='anchor' id='hw'>

# 1. Постройте график зависимости весов всех признаков от lambda в самописной L2-регуляризации (на данных про ЕГЭ). Сделайте вывод

# In[3]:


X = np.array([[   1,    1,  500,    1],
              [   1,    1,  700,    1],
              [   1,    2,  750,    2],
              [   1,    5,  600,    1],
              [   1,    3, 1450,    2],
              [   1,    0,  800,    1],
              [   1,    5, 1500,    3],
              [   1,   10, 2000,    3],
              [   1,    1,  450,    1],
              [   1,    2, 1000,    2]])

y = [45,55,50,55,60,35,75,80,50,60]


# In[4]:


def standard_scale(X):
    mean = X.mean()
    std = X.std()
    return (X - mean)/std


# In[5]:


def normal_scale(X):
    min_X = X.min()
    max_X = X.max()
    return (X - min_X)/ (max_X - min_X)


# In[6]:


def calc_mse(y, y_pred):
    err = np.mean((y - y_pred)**2)
    return err


# In[7]:


X_st = X.copy().astype(np.float64);
X_st[: , 1] = standard_scale(X_st[: , 1])
X_st[: ,2] = standard_scale(X_st[: ,2])
X_st


# In[8]:


def gradient_descent_reg_l2(X, y, iterations, eta=1e-4, reg=1e-8):
    W = np.random.randn(X.shape[1])
    n = X.shape[0]
    
    for i in range(0, iterations):
        y_pred = np.dot(X, W)
        err = calc_mse(y, y_pred)
        
        dQ = 2/n * X.T @ (y_pred - y) # градиент функции ошибки
        dReg = reg * W # градиент регуляризации
        
        W -= eta * (dQ + dReg)
        
        if i % (iterations / 10) == 0:
            print(f'Iter: {i}, weights: {W}, error {err}')
    
    print(f'Final MSE: {calc_mse(y, np.dot(X, W))}')
    return W


# In[9]:


W = gradient_descent_reg_l2(X_st, y, iterations= 6000, eta=1e-2, reg= 1e-4)


# In[10]:


W_list = [];
reg_list = [];

for reg in np.arange(0, 1, 0.05):
    print(f'reg (lamba) = {reg}')
    W = gradient_descent_reg_l2(X_st, y, iterations = 5000, eta=1e-2, reg=reg)
    W_list.append(W)
    reg_list.append(reg)


# In[11]:


plt.plot(reg_list, W_list)
plt.title('график зависимости весов всех признаков \n от lambda в самописной L2-регуляризации')
plt.xlabel('reg (lambda)')
plt.ylabel('Веса признаков')


# 2. Напишите функцию наподобие gradient_descent_reg_l2, но для применения L1-регуляризации.

# In[12]:


def gradient_descent_reg_l1(X, y, iterations, eta= 1e-4, reg= 1e-8):
    W = np.random.randn(X.shape[1])
    n = X.shape[0]
    
    for i in range(0 , iterations):
        y_pred = np.dot(X, W)
        err = calc_mse(y , y_pred)
        
        dQ = 2/n * X.T @ (y_pred - y)
        dReg = reg * np.sign(W)
        
        W -= eta * dQ + dReg
        
        if i % (iterations / 10 ) == 0:
            print(f'Iter: {i}, weights: {W}, error {err}')
    print( f'Final MSE: {calc_mse(y, np.dot(X, W))}')
    return W


# In[13]:


W = gradient_descent_reg_l1(X_st, y , iterations= 5000, eta= 1e-2, reg= 1e-4)


# In[14]:


W_list = [];
reg_list = [];

for reg in np.arange(0, 1, 0.05):
    print(f'reg (lamba) = {reg}')
    W = gradient_descent_reg_l2(X_st, y, iterations = 6000, eta=1e-2, reg=reg)
    W_list.append(W)
    reg_list.append(reg)


# In[15]:


plt.plot(reg_list, W_list)
plt.title('график зависимости весов всех признаков \n от lambda в самописной L1-регуляризации')
plt.xlabel('reg (lambda)')
plt.ylabel('Веса признаков')


# 3. *Можно ли к одному и тому же признаку применить сразу и нормализацию, и стандартизацию?

# 4. *Сгенерируйте датасет при помощи <code>sklearn.datasets.make_regression</code> и обучите линейную модель при помощи градиентного и стохастического градиентного спуска. Нанесите среднеквадратичную ошибку для обоих методов на один график, сделайте выводы о разнице скорости сходимости каждого из методов.

# Проект*: 
# 1. https://www.kaggle.com/c/gb-tutors-expected-math-exam-results регрессия
# 1. https://www.kaggle.com/c/gb-choose-tutors классификация

# ## Литература

# 1. [Стохастический градиентный спуск](http://www.machinelearning.ru/wiki/index.php?title=%D0%A1%D1%82%D0%BE%D1%85%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B3%D1%80%D0%B0%D0%B4%D0%B8%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D1%83%D1%81%D0%BA)
# 2. [sklearn.datasets.make_regression](https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_regression.html)
# 3. [numpy.mean](https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.mean.html)
# 4. [sklearn.linear_model.LinearRegression](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html)
# 5. [sklearn.preprocessing.PolynomialFeatures](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html)
# 6. [sklearn.pipeline.make_pipeline](https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.make_pipeline.html)
# 7. [Переобучение и Недообучение. Видео](https://youtu.be/m7P7bnLxIc4)

# ## Summary

# _Масштабирование_
# * Масштабирование признаков - хорошая практика, позволяющая обучать модели быстрее и делающая их более точными
# * При использовании метрических алгоритмов масштабирование обязательно (!)
# 
# _Стохастический градиентный спуск_
# * Стохастический градиентный спуск (SGD) - на каждом шаге уменьшаем ошибку только на одном объекте (или нескольких), а не на всей выборке, работает быстрее обычного GD, т.к. меньше вычислений
# * SGD из-за стохастичности может "перепрыгнуть" локальный минимум и попасть в глобальный
# 
# _Регуляризация_
# * Переобучение - модель "выучила" выборку, но обобщающая способность слабая
# * Признаки переобучения: качество на трейне высокое, а на тесте низкое, большие веса модели
# * Один из способов борьбы с переобучением - регуляризация - штраф за большие веса

# ### Определения
# *Масштабирование данных*
# 
# **Нормализация данных** — метод предобработки числовых признаков в обучающих наборах данных с целью приведения их к некоторой общей шкале без потери информации о различии диапазонов. (шкала от 0 до 1)
# 
# **Стандартизация** — метод предобработки с целью приведения данных к единому формату и представлению. (М=0, std=1)
# ___________
# _Стохастический градиентный спуск_
# 
# **Стохастический градиентный спуск** — метод нахождения локального экстремума функции (минимума или максимума) с помощью движения вдоль градиента, который считается на каждом шаге не как сумма градиентов от каждого элемента выборки, а как градиент от одного, случайно выбранного элемента.
# 
# ___________
# _Переобучение_
# 
# **Переобучение** (overfitting) — явление, когда алгоритм хорошо объясняет примеры из обучающей выборки (обеспечивает малую величину ошибки), но плохо работает на примерах, не участвовавших в обучении (не обеспечивает малую величину ошибки).
# 
# **Недообучение** (underfitting) — явление, при котором алгоритм обучения не обеспечивает достаточно малой величины средней ошибки на обучающей выборке.
# 
# **Кросс-валидация** — процедура оценивания обобщающей способности алгоритмов. С её помощью эмулируется наличие тестовой выборки, которая не участвует в обучении, но для которой известны правильные ответы.
# 
# ________
# _Регуляризация_
# 
# **Регуляризация** — метод добавления некоторых дополнительных ограничений к условию с целью решить некорректно поставленную задачу или предотвратить переобучение. Эта информация часто имеет вид штрафа за сложность модели.
# $$Q(w, X) + \lambda ||w||^{2} \rightarrow \underset{w}{\text{min}}.$$
# 
# **L1-регуляризация** (lasso, регуляризация через манхэттенское расстояние) — метод добавления дополнительных ограничений в виде $L_{1}$-норму вектора весов, то есть сумму модулей весов. 
# $$||w||_{1} = \sum^{d}_{j=1}|w_{j}|.$$
# 
# **L2-регуляризация** (ridge, регуляризация Тихонова) — метод добавления дополнительных ограничений в виде $L_{2}$-норму вектора весов, то есть сумму квадратов весов. 
# $$||w||_{2} = \sum^{d}_{j=1}w^{2}.$$
# 
# 
